// 5G-MAG Reference Tools
// MBMS Middleware Process
//
// Copyright (C) 2021 Klaus Kühnhammer (Österreichische Rundfunksender GmbH & Co KG)
//
// Licensed under the License terms and conditions for use, reproduction, and
// distribution of 5G-MAG software (the “License”).  You may not use this file
// except in compliance with the License.  You may obtain a copy of the License at
// https://www.5g-mag.com/reference-tools.  Unless required by applicable law or
// agreed to in writing, software distributed under the License is distributed on
// an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
// or implied.
// 
// See the License for the specific language governing permissions and limitations
// under the License.
//

#include <regex>
#include "SeamlessContentStream.h"
#include "CdnClient.h"
#include "CacheItems.h"
#include "HlsMediaPlaylist.h"
#include <libgen.h>
#include <boost/bind/bind.hpp>
#include "spdlog/spdlog.h"
#include "cpprest/base_uri.h"
#include "cpprest/uri_builder.h"

MBMS_RT::SeamlessContentStream::SeamlessContentStream(std::string base, std::string flute_if, boost::asio::io_service& io_service, CacheManagement& cache, DeliveryProtocol protocol)//, const libconfig::Config& cfg)
  : ContentStream( std::move(base), std::move(flute_if), cache, protocol)//, cfg)
  , _tick_interval(1)
  , _io_service(io_service)
  , _timer(io_service, _tick_interval)
{
 // cfg.lookupValue("mw.cache.max_segments_per_stream", _segments_to_keep);
 // cfg.lookupValue("mw.seamless_switching.truncate_cdn_playlist_segments", _truncate_cdn_playlist_segments);
  _timer.async_wait(boost::bind(&SeamlessContentStream::tick_handler, this)); //NOLINT
  _segments.emplace_back(std::map<int, std::shared_ptr<Segment>>());
  _segments.emplace_back(std::map<int, std::shared_ptr<Segment>>());
}

MBMS_RT::SeamlessContentStream::~SeamlessContentStream() {
  spdlog::debug("Destroying seamless content stream at base {}", _base);
}

void MBMS_RT::SeamlessContentStream::stop() {
    _running = false;
    _timer.cancel();
}

auto MBMS_RT::SeamlessContentStream::flute_file_received(std::shared_ptr<LibFlute::File> file) -> void {
  spdlog::info("SeamlessContentStream: {} (TOI {}, MIME type {}) has been received via 5GBC",
      file->meta().content_location, file->meta().toi, file->meta().content_type);

  if (file->meta().content_location == _playlist_path) {
    spdlog::debug("ContentStream: got PLAYLIST at {} via 5GBC", file->meta().content_location);
    handle_playlist(std::string(file->buffer(), file->length()), MBMS_RT::ItemSource::Broadcast);
  } else if (file->meta().content_location == "ch2/stream.m3u8") {
    spdlog::debug("ContentStream: got PLAYLIST at {} via 5GBC", file->meta().content_location);
    handle_playlist(std::string(file->buffer(), file->length()), MBMS_RT::ItemSource::Broadcast,1);
  } else if (file->meta().content_location == "index.m3u8") {
    // ignore the pathless master manifest generated by the core
  } else {
    spdlog::debug("ContentStream: got SEGMENT at {} via 5GBC", file->meta().content_location);
    _flute_files[file->meta().content_location] = file;
  }
}

auto MBMS_RT::SeamlessContentStream::set_cdn_endpoint(const std::string& cdn_ept) -> void
{
  web::uri uri(cdn_ept);
  web::uri_builder cdn_base(cdn_ept);

  std::string path = uri.path();
  _playlist_path = path.erase(0,1);// + "?" + uri.query();
  spdlog::debug("ContentStream: playlist location is {}", _playlist_path);
  size_t spos = _playlist_path.rfind('/');
  _playlist_dir = _playlist_path.substr(0, spos+1);
  spdlog::debug("ContentStream: playlist dir is {}", _playlist_dir);
  //cdn_base.set_path("/");
  cdn_base.set_path("/cdn/");
  cdn_base.set_query("");
  _cdn_endpoint = cdn_base.to_string(); 
  spdlog::info("ContentStream: setting CDN ept to {}", _cdn_endpoint);

  _cdn_client = std::make_shared<CdnClient>(_io_service, cdn_base.host(), cdn_base.port(), cdn_base.path());

  _cache.add_item( std::make_shared<CachedPlaylist>(
        _playlist_path,
        0,
        [&]() -> const std::string& {
          spdlog::debug("ContentStream: {} playlist requested", _playlist_path);
          return _playlist;
        }
        ));
  _cache.add_item( std::make_shared<CachedPlaylist>(
        "ch2/stream.m3u8",
        0,
        [&]() -> const std::string& {
          spdlog::debug("ContentStream: {} playlist requested", _playlist_path);
          return _playlist2;
        }
        ));
};


auto MBMS_RT::SeamlessContentStream::handle_playlist( const std::string& content, ItemSource source, int plidx) -> void
{
  auto playlist = MBMS_RT::HlsMediaPlaylist(content);
  int seq = 0;
  double extinf = 0;

  auto count = playlist.segments().size();
  if (source == ItemSource::CDN) {
    count -= _truncate_cdn_playlist_segments;
  }
  int idx = 0;

  const std::lock_guard<std::mutex> lock(_segments_mutex);

  for (const auto& segment : playlist.segments()) {
   // spdlog::debug("segment: seq {}, extinf {}, uri {}", segment.seq, segment.extinf, segment.uri);
    if (_segments[plidx].find(segment.seq) == _segments[plidx].end()) {
      std::string full_uri = (plidx == 0 ? "ch1/" : "ch2/") + segment.uri;
      auto seg =
        std::make_shared<Segment>(full_uri, segment.seq, segment.extinf);
      if (_cdn_client) {
        seg->set_cdn_client(_cdn_client);
      }

      if (_flute_files.find(full_uri) != _flute_files.end()) {
        seg->set_flute_file(_flute_files[full_uri]);
        _flute_files.erase(full_uri);
        spdlog::debug("Assigned already received flute file");
      }

      _segments[plidx][segment.seq] = seg;

      _cache.add_item( std::make_shared<CachedSegment>(
            full_uri, 0, seg )
          );
    }
    if (idx++ > count) {
      break;
    }
  }

  while (_segments[plidx].size() > _segments_to_keep) {
    auto seg = _segments[plidx].extract(_segments[plidx].begin());
    spdlog::debug("Removing oldest segment and cache item at {}", seg.mapped()->uri());
    _cache.remove_item(seg.mapped()->uri());
  }
  HlsMediaPlaylist pl;
  pl.set_target_duration(playlist.target_duration());  // [TODO] this will fail when targetdurations change or do not match
  for (const auto& seg : _segments[plidx]) {
    HlsMediaPlaylist::Segment s{
      seg.second->uri(),
      seg.second->seq(),
      seg.second->extinf(),
    };
    pl.add_segment(s);
  }
  if (plidx == 0) {
  _playlist = pl.to_string();
  } else {
  _playlist2 = pl.to_string();
  }
}

auto MBMS_RT::SeamlessContentStream::tick_handler() -> void
{
  spdlog::debug("SeamlessContentStream tick");
  if (!_running) return;

  spdlog::info("SeamlessContentStream: refreshing playlist(s) from CDN at {}", _playlist_path);
  if (_cdn_client) {
    _cdn_client->get(_playlist_path,
        [&](std::shared_ptr<CdnFile> file) -> void { //NOLINT
        spdlog::debug("Playlist received from CDN");
            handle_playlist(std::string(file->buffer(), file->length()), MBMS_RT::ItemSource::CDN);
            _cdn_client->get("ch2/stream.m3u8",
                             [&](std::shared_ptr<CdnFile> file) -> void { //NOLINT
                                 spdlog::debug("Playlist received from CDN");
                                 handle_playlist(std::string(file->buffer(), file->length()), MBMS_RT::ItemSource::CDN, 1);
                                 _timer.expires_at(_timer.expires_at() + _tick_interval);
                                 _timer.async_wait(boost::bind(&SeamlessContentStream::tick_handler, this)); //NOLINT
                             },
                     [&]() -> void {
                         _timer.expires_at(_timer.expires_at() + _tick_interval);
                         _timer.async_wait(boost::bind(&SeamlessContentStream::tick_handler, this)); //NOLINT
                     });
            },
           [&]() -> void {
               _timer.expires_at(_timer.expires_at() + _tick_interval);
               _timer.async_wait(boost::bind(&SeamlessContentStream::tick_handler, this)); //NOLINT
           });
  }
 // _timer.expires_at(_timer.expires_at() + _tick_interval);
 // _timer.async_wait(boost::bind(&SeamlessContentStream::tick_handler, this)); //NOLINT
  //spdlog::debug("SeamlessContentStream tick done");
}

